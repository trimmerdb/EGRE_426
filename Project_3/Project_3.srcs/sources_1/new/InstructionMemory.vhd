library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;

entity InstructionMemory is
    generic (
        ADDR_WIDTH : integer := 16
    );
    port (
        clk   : in  std_logic;
        addr  : in  unsigned(15 downto 0);
        instr : out unsigned(15 downto 0)
    );
end entity InstructionMemory;

architecture Behavioral of InstructionMemory is
    constant DEPTH : integer := 256;

    type rom_type is array (0 to DEPTH - 1) of unsigned(15 downto 0);

    signal ROM : rom_type := (
        0  => "0110000000000000",
        1  => "0000000000000000",
        
        2  => "0010000000000001",
        3  => "0000000000000000",
        
        4  => "1110000000000110",
        5  => "0000000000000000",
        
        6  => "0110001001000000",
        7  => "0000000000000000",
        
        8  => "0010001001000001",
        9  => "0000000000000000",
        
        10  => "1110001001000111",
        11  => "0000000000000000",
        
        12  => "0010001001000001",
        13  => "0000000000000000",
        
        14  => "1110001001000100",
        15  => "0000000000000000",
         
        16  => "0110010010000000",
        17  => "0000000000000000",
         
        18  => "0010010010001111",
        19  => "0000000000000000",
         
        20 => "0110011011000000",
        21 => "0000000000000000",
         
        22 => "0010011011001111",
        23 => "0000000000000000",
         
        24 => "1110011011000100",
        25 => "0000000000000000",
         
        26 => "0110100100000000",
        27 => "0000000000000000",
         
        28 => "0110101101000000",
        29 => "0000000000000000",
        
        30 => "0010101101000001",
        31 => "0000000000000000",
         
        32 => "1110101101000100",
        33 => "0000000000000000",
         
        34 => "0110110110000000",
        35 => "0000000000000000",
         
        36 => "0010110110000101",
        37 => "0000000000000000",
         
        38 => "0011110110000001",
        39 => "0000000000000000",
         
        40 => "0010100101000000",
        41 => "0000000000000000",
         
        42 => "0110111111000000",
        43 => "0000000000000000",
         
        44 => "0010111111000001",
        45 => "0000000000000000",
         
        46 => "1110111111001000",
        47 => "0000000000000000",
         
        48 => "1101100111001100",
        49 => "0000000000000000",
         
        50 => "0100100100000100",
        51 => "0000000000000000",
         
        52 => "0000011011010110",
        53 => "0000000000000000",
         
        54 => "0110101101000000",
        55 => "0000000000000000",
         
        56 => "0010101101001111",
        57 => "0000000000000000",
         
        58 => "1110101101000100",
        59 => "0000000000000000",
         
        60 => "0110101101001111",
        61 => "0000000000000000",
         
        62 => "0010101101000010",
        63 => "0000000000000000",
         
        64 => "0110111111000000",
        65 => "0000000000000000",
         
        66 => "0010111111000001",
        67 => "0000000000000000",
         
        68 => "1001110111001011",
        69 => "0000000000000000",
         
        70 => "1101000000101000",
        71 => "0000000000000000",
         
        72 => "0101000000001000",
        73 => "0000000000000000",
         
        74 => "0000001001000101",
        75 => "0000000000000000",
         
        76 => "0110101101000000",
        77 => "0000000000000000",
         
        78 => "0010101101001111",
        79 => "0000000000000000",
         
        80 => "1110101101000100",
        81 => "0000000000000000",
        
        82 => "0110101101001111",
        83 => "0000000000000000",
         
        84 => "1110101101001000",
        85 => "0000000000000000",
         
        86 => "1101000001000000",
        others => (others => '0')
    );

begin
    process(clk)
        variable index : integer;
    begin
        if rising_edge(clk) then
            index := to_integer(addr);
            if index >= 0 and index < DEPTH then
                instr <= ROM(index);
            else
                instr <= (others => '0');
            end if;
        end if;
    end process;

end architecture Behavioral;
